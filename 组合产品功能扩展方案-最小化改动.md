# 组合产品功能扩展方案 - 最小化改动版

> 基于现有 `dm_product_info` 表扩展，最小化数据库变更

---

## 方案对比总表

| 项目 | 方案一：最小化改动（推荐）⭐ | 方案二：JSON字段（不推荐）|
|-----|----------------------|---------------------|
| **数据库变更** | | |
| 修改现有表字段 | **仅增加2个字段** | 增加3个字段（含JSON） |
| 新增表数量 | 1张关联表 | 0张（完全不增加） |
| **功能特性** | | |
| 复用ProductInfo功能 | ✅ 完全复用 | ✅ 完全复用 |
| 数据一致性 | ✅ 外键约束 | ❌ 无约束 |
| 查询性能 | ✅ 优秀（JOIN查询） | ❌ 差（JSON解析） |
| SQL查询子产品 | ✅ 支持 | ❌ 不支持 |
| **维护性** | | |
| 数据结构清晰度 | ✅ 清晰 | ⚠️ 一般 |
| 扩展性 | ✅ 易扩展 | ❌ 困难 |
| 维护难度 | ✅ 简单 | ⚠️ 复杂 |
| **推荐度** | ⭐⭐⭐⭐⭐ | ⭐⭐ |

---

## 方案对比

### 方案一：只增加一张明细表（推荐）⭐
- ✅ 最小化改动，只需1张新表 + 2个字段
- ✅ 组合产品可以复用现有ProductInfo的所有功能
- ✅ 数据结构清晰，易于维护
- ✅ **复用 cost_price 字段，无需额外成本价字段**
- ❌ 需要新增1张表

### 方案二：完全不增加表（JSON字段方案）
- ✅ 完全不需要新表
- ❌ JSON字段查询性能差
- ❌ 无法建立外键约束
- ❌ 数据一致性难以保证
- ⚠️ **不推荐**，除非有特殊限制

---

## 方案一：最小化改动方案（推荐）

### 一、表结构设计

#### 1.1 修改现有表 `dm_product_info`

```sql
-- 在 dm_product_info 表中添加字段（只需2个字段！）
ALTER TABLE `dm_product_info` 
ADD COLUMN `product_type` int DEFAULT 0 COMMENT '产品类型：0=普通产品 1=组合产品',
ADD COLUMN `bundle_type` int DEFAULT NULL COMMENT '组合类型：1=自定义成本价 2=自动累计成本价（仅组合产品有效）',
ADD INDEX `idx_product_type` (`product_type`, `deleted`);

-- 说明：
-- product_type = 0: 普通产品（默认）
-- product_type = 1: 组合产品
-- bundle_type = 1: 自定义成本价（cost_price由用户手动设置）
-- bundle_type = 2: 自动累计成本价（cost_price自动计算）
-- cost_price 字段：【复用原有字段】存储最终成本价
```

**字段说明：**
- `product_type`: 标识产品类型，0=普通产品，1=组合产品
- `bundle_type`: 仅组合产品使用，决定成本价计算方式
  - 1 = 自定义模式：`cost_price` 由用户手动设置，不随子产品成本变化
  - 2 = 自动累计模式：`cost_price` 自动计算（子产品成本之和）
- `cost_price`: **复用原有字段**，存储最终成本价（无需额外字段）

#### 1.2 新增关联表 `dm_product_bundle_relation`（唯一新增表）

```sql
-- 组合产品关联表（只存储关联关系，不冗余数据）
CREATE TABLE `dm_product_bundle_relation` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  
  -- 关联关系（核心）
  `bundle_product_id` bigint NOT NULL COMMENT '组合产品ID（dm_product_info.id）',
  `sub_product_id` bigint NOT NULL COMMENT '子产品ID（dm_product_info.id）',
  
  -- 组合配置
  `quantity` int NOT NULL DEFAULT 1 COMMENT '数量',
  `sort_order` int DEFAULT 0 COMMENT '排序',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  
  -- 审计字段
  `creator` varchar(64) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updater` varchar(64) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',
  `tenant_id` bigint DEFAULT 0 COMMENT '租户ID',
  
  PRIMARY KEY (`id`),
  KEY `idx_bundle_product` (`bundle_product_id`, `deleted`),
  KEY `idx_sub_product` (`sub_product_id`),
  KEY `idx_tenant` (`tenant_id`, `deleted`),
  UNIQUE KEY `uk_bundle_sub` (`bundle_product_id`, `sub_product_id`, `deleted`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='产品组合关系表';
```

**设计原则：**
- ✅ **不存储冗余数据**：子产品的 SKU、名称、单价等信息都从 `dm_product_info` 实时获取
- ✅ **数据一致性**：子产品信息变更时，查询自动反映最新数据
- ✅ **表结构精简**：只存储关联关系和配置信息
- ✅ **性能考虑**：通过 JOIN 查询获取完整信息

**优势：**
- 组合产品本身就是一条 `dm_product_info` 记录
- 可以复用现有的分类、品牌、供应商等所有功能
- 只需要1张关联表来维护组合关系
- 子产品信息变更自动生效，无需同步

---

### 二、数据模型设计

#### 2.1 修改现有 ProductInfoDO

```java
@TableName("dm_product_info")
@Data
@EqualsAndHashCode(callSuper = true)
public class ProductInfoDO extends BaseDO {

    private Long id;
    private String skuId;
    private String skuName;
    // ... 其他原有字段 ...
    private BigDecimal costPrice;  // 最终成本价（复用原有字段）
    
    // ========== 新增字段（只需2个！） ==========
    
    /**
     * 产品类型：0=普通产品 1=组合产品
     */
    private Integer productType;
    
    /**
     * 组合类型：1=自定义成本价 2=自动累计成本价
     * （仅当 productType=1 时有效）
     */
    private Integer bundleType;
    
    // 注意：cost_price 字段复用，无需额外字段存储成本价
}
```

#### 2.2 新增 ProductBundleRelationDO（精简版）

```java
package cn.iocoder.yudao.module.dm.dal.dataobject.product;

import cn.iocoder.yudao.framework.tenant.core.db.TenantBaseDO;
import com.baomidou.mybatisplus.annotation.*;
import lombok.*;

/**
 * 产品组合关系 DO
 * 
 * 设计原则：只存储关联关系，不冗余存储子产品信息
 * 子产品的详细信息通过 JOIN dm_product_info 表获取
 *
 * @author zeno
 */
@TableName("dm_product_bundle_relation")
@KeySequence("dm_product_bundle_relation_seq")
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductBundleRelationDO extends TenantBaseDO {

    /**
     * 主键
     */
    @TableId
    private Long id;
    
    /**
     * 组合产品ID（dm_product_info.id）
     */
    private Long bundleProductId;
    
    /**
     * 子产品ID（dm_product_info.id）
     */
    private Long subProductId;
    
    /**
     * 数量
     */
    private Integer quantity;
    
    /**
     * 排序
     */
    private Integer sortOrder;
    
    /**
     * 备注
     */
    private String remark;
    
    // 注意：子产品的 SKU、名称、单价等信息不在此表存储
    // 查询时通过 JOIN dm_product_info 表获取实时数据
}
```

---

### 三、VO层设计

#### 3.1 扩展现有 ProductInfoSaveReqVO

```java
@Schema(description = "管理后台 - 产品信息新增/修改 Request VO")
@Data
public class ProductInfoSaveReqVO {

    private Long id;
    private String skuId;
    private String skuName;
    // ... 其他原有字段 ...
    private BigDecimal costPrice;
    
    // ========== 新增：组合产品相关字段 ==========
    
    @Schema(description = "产品类型：0=普通产品 1=组合产品")
    private Integer productType;
    
    @Schema(description = "组合类型：1=自定义成本价 2=自动累计成本价")
    private Integer bundleType;
    
    @Schema(description = "组合产品明细列表（仅productType=1时填写）")
    @Valid
    private List<ProductBundleItemReqVO> bundleItems;
    
    // 注意：costPrice字段复用
    // - bundleType=1时：用户手动设置costPrice
    // - bundleType=2时：系统自动计算costPrice（基于bundleItems）
    
    // ... 其他原有字段 ...
}
```

#### 3.2 新增 ProductBundleItemReqVO

```java
@Schema(description = "组合产品明细")
@Data
public class ProductBundleItemReqVO {
    
    @Schema(description = "子产品ID", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotNull(message = "子产品ID不能为空")
    private Long subProductId;
    
    @Schema(description = "数量", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotNull(message = "数量不能为空")
    @Min(value = 1, message = "数量至少为1")
    private Integer quantity;
    
    @Schema(description = "排序")
    private Integer sortOrder;
    
    @Schema(description = "备注")
    private String remark;
}
```

#### 3.3 扩展现有 ProductInfoRespVO

```java
@Schema(description = "管理后台 - 产品信息 Response VO")
@Data
public class ProductInfoRespVO {
    
    private Long id;
    private String skuId;
    private String skuName;
    // ... 其他原有字段 ...
    private BigDecimal costPrice;
    
    // ========== 新增：组合产品相关字段 ==========
    
    @Schema(description = "产品类型：0=普通产品 1=组合产品")
    private Integer productType;
    
    @Schema(description = "组合类型")
    private Integer bundleType;
    
    @Schema(description = "组合产品明细列表（仅组合产品）")
    private List<ProductBundleItemRespVO> bundleItems;
    
    // ... 其他原有字段 ...
}
```

#### 3.4 新增 ProductBundleItemRespVO

```java
@Schema(description = "组合产品明细响应")
@Data
public class ProductBundleItemRespVO {
    
    @Schema(description = "关系ID")
    private Long id;
    
    @Schema(description = "子产品ID")
    private Long subProductId;
    
    // ========== 以下字段从 dm_product_info 表 JOIN 获取（实时数据）==========
    
    @Schema(description = "子产品SKU（实时）")
    private String subSkuId;
    
    @Schema(description = "子产品名称（实时）")
    private String subSkuName;
    
    @Schema(description = "单位（实时）")
    private String unit;
    
    @Schema(description = "单位成本价（实时）")
    private BigDecimal unitCostPrice;
    
    // ========== 以下字段从关系表获取 ==========
    
    @Schema(description = "数量")
    private Integer quantity;
    
    @Schema(description = "总成本价（计算：unitCostPrice * quantity）")
    private BigDecimal totalCostPrice;
    
    @Schema(description = "排序")
    private Integer sortOrder;
    
    @Schema(description = "备注")
    private String remark;
}
```

---

### 四、Service层实现（扩展现有 ProductInfoService）

```java
public interface ProductInfoService {
    
    // ========== 现有方法 ==========
    Long createProductInfo(@Valid ProductInfoSaveReqVO createReqVO);
    void updateProductInfo(@Valid ProductInfoSaveReqVO updateReqVO);
    // ... 其他现有方法 ...
    
    // ========== 新增：组合产品相关方法 ==========
    
    /**
     * 获取组合产品的明细列表
     *
     * @param bundleProductId 组合产品ID
     * @return 明细列表
     */
    List<ProductBundleRelationDO> getBundleRelations(Long bundleProductId);
    
    /**
     * 重新计算组合产品成本价
     *
     * @param bundleProductId 组合产品ID
     */
    void recalculateBundleCostPrice(Long bundleProductId);
    
    /**
     * 批量重新计算组合产品成本价（定时任务）
     */
    void batchRecalculateBundleCostPrice();
}
```

#### 4.1 Service实现关键代码

```java
@Service
@Validated
@Slf4j
public class ProductInfoServiceImpl implements ProductInfoService {

    @Resource
    private ProductInfoMapper productInfoMapper;
    
    @Resource
    private ProductBundleRelationMapper bundleRelationMapper;
    
    // 其他现有依赖...

    @Override
    @Transactional(rollbackFor = Exception.class)
    public Long createProductInfo(@Valid ProductInfoSaveReqVO createReqVO) {
        // 1. 原有的创建逻辑...
        ProductInfoDO product = BeanUtils.toBean(createReqVO, ProductInfoDO.class);
        
        // 2. 如果是组合产品，需要额外处理
        if (createReqVO.getProductType() != null && createReqVO.getProductType() == 1) {
            // 2.1 校验组合产品数据
            validateBundleProduct(createReqVO);
            
            // 2.2 创建明细
            List<ProductBundleRelationDO> relations = createBundleRelations(null, createReqVO.getBundleItems());
            
            // 2.3 计算最终成本价
            BigDecimal finalCostPrice = calculateBundleCostPrice(
                createReqVO.getBundleType(), 
                createReqVO.getCustomCostPrice(), 
                relations
            );
            
            // 设置最终成本价到 cost_price 字段
            product.setCostPrice(finalCostPrice);
        }
        
        // 3. 插入主记录
        productInfoMapper.insert(product);
        Long productId = product.getId();
        
        // 4. 如果是组合产品，插入明细
        if (createReqVO.getProductType() != null && createReqVO.getProductType() == 1) {
            List<ProductBundleRelationDO> relations = createBundleRelations(productId, createReqVO.getBundleItems());
            relations.forEach(bundleRelationMapper::insert);
        }
        
        // 5. 原有的其他子表处理...
        // productCustoms, productPrices, etc.
        
        return productId;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void updateProductInfo(@Valid ProductInfoSaveReqVO updateReqVO) {
        // 1. 校验存在
        validateProductInfoExists(updateReqVO.getId());
        
        // 2. 更新主记录
        ProductInfoDO updateObj = BeanUtils.toBean(updateReqVO, ProductInfoDO.class);
        
        // 3. 如果是组合产品，重新处理明细
        if (updateReqVO.getProductType() != null && updateReqVO.getProductType() == 1) {
            // 3.1 校验
            validateBundleProduct(updateReqVO);
            
            // 3.2 删除旧明细
            bundleRelationMapper.deleteByBundleProductId(updateReqVO.getId());
            
            // 3.3 创建新明细
            List<ProductBundleRelationDO> relations = createBundleRelations(
                updateReqVO.getId(), 
                updateReqVO.getBundleItems()
            );
            
            // 3.4 重新计算成本价
            BigDecimal finalCostPrice = calculateBundleCostPrice(
                updateReqVO.getBundleType(), 
                updateReqVO.getCostPrice(),  // bundleType=1时，用户传入的cost_price
                relations
            );
            
            // 设置最终成本价
            updateObj.setCostPrice(finalCostPrice);
            
            // 3.5 插入新明细
            relations.forEach(bundleRelationMapper::insert);
        }
        
        // 4. 更新数据库
        productInfoMapper.updateById(updateObj);
        
        // 5. 原有的其他子表处理...
    }

    @Override
    public ProductInfoRespVO getProductInfo(Long id) {
        // 1. 查询产品基本信息
        ProductInfoDO product = productInfoMapper.selectById(id);
        if (product == null) {
            return null;
        }
        
        ProductInfoRespVO respVO = BeanUtils.toBean(product, ProductInfoRespVO.class);
        
        // 2. 如果是组合产品，查询明细并关联子产品信息
        if (product.getProductType() != null && product.getProductType() == 1) {
            List<ProductBundleRelationDO> relations = bundleRelationMapper
                    .selectListByBundleProductId(id);
            
            // 3. 组装明细数据（实时获取子产品信息）
            List<ProductBundleItemRespVO> itemRespVOs = new ArrayList<>();
            
            for (ProductBundleRelationDO relation : relations) {
                // 实时查询子产品信息
                ProductInfoDO subProduct = productInfoMapper.selectById(relation.getSubProductId());
                if (subProduct != null) {
                    ProductBundleItemRespVO itemRespVO = new ProductBundleItemRespVO();
                    itemRespVO.setId(relation.getId());
                    itemRespVO.setSubProductId(relation.getSubProductId());
                    itemRespVO.setQuantity(relation.getQuantity());
                    itemRespVO.setSortOrder(relation.getSortOrder());
                    itemRespVO.setRemark(relation.getRemark());
                    
                    // 从子产品获取实时信息
                    itemRespVO.setSubSkuId(subProduct.getSkuId());
                    itemRespVO.setSubSkuName(subProduct.getSkuName());
                    itemRespVO.setUnit(subProduct.getUnit());
                    itemRespVO.setUnitCostPrice(subProduct.getCostPrice());
                    
                    // 计算总成本价
                    if (subProduct.getCostPrice() != null) {
                        itemRespVO.setTotalCostPrice(
                            subProduct.getCostPrice().multiply(new BigDecimal(relation.getQuantity()))
                        );
                    }
                    
                    itemRespVOs.add(itemRespVO);
                }
            }
            
            respVO.setBundleItems(itemRespVOs);
        }
        
        return respVO;
    }

    @Override
    public List<ProductBundleRelationDO> getBundleRelations(Long bundleProductId) {
        return bundleRelationMapper.selectListByBundleProductId(bundleProductId);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void recalculateBundleCostPrice(Long bundleProductId) {
        // 1. 获取产品
        ProductInfoDO product = productInfoMapper.selectById(bundleProductId);
        if (product == null || product.getProductType() != 1) {
            throw exception(PRODUCT_NOT_BUNDLE);
        }
        
        // 2. 仅自动累计模式需要重算
        if (product.getBundleType() != 2) {
            log.warn("[recalculateBundleCostPrice] 产品{}为自定义成本价模式，跳过", bundleProductId);
            return;
        }
        
        // 3. 获取关联关系
        List<ProductBundleRelationDO> relations = bundleRelationMapper.selectListByBundleProductId(bundleProductId);
        
        // 4. 实时查询子产品成本价并计算总成本
        BigDecimal totalCost = BigDecimal.ZERO;
        
        for (ProductBundleRelationDO relation : relations) {
            // 实时获取子产品信息（不存储快照）
            ProductInfoDO subProduct = productInfoMapper.selectById(relation.getSubProductId());
            if (subProduct != null && subProduct.getCostPrice() != null) {
                // 计算该项成本：单价 * 数量
                BigDecimal itemCost = subProduct.getCostPrice()
                        .multiply(new BigDecimal(relation.getQuantity()));
                totalCost = totalCost.add(itemCost);
            }
        }
        
        // 5. 更新产品成本价
        ProductInfoDO updateObj = new ProductInfoDO();
        updateObj.setId(bundleProductId);
        updateObj.setCostPrice(totalCost);
        productInfoMapper.updateById(updateObj);
        
        log.info("[recalculateBundleCostPrice] 重新计算成本价成功，ID={}, 新成本价={}", 
                 bundleProductId, totalCost);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void batchRecalculateBundleCostPrice() {
        // 查询所有自动累计模式的组合产品
        List<ProductInfoDO> bundleProducts = productInfoMapper.selectListByProductTypeAndBundleType(1, 2);
        
        for (ProductInfoDO product : bundleProducts) {
            try {
                recalculateBundleCostPrice(product.getId());
            } catch (Exception e) {
                log.error("[batchRecalculateBundleCostPrice] 重新计算产品{}成本价失败", 
                          product.getId(), e);
            }
        }
        
        log.info("[batchRecalculateBundleCostPrice] 批量重新计算完成，共{}个", bundleProducts.size());
    }

    // ==================== 私有方法 ====================

    /**
     * 校验组合产品数据
     */
    private void validateBundleProduct(ProductInfoSaveReqVO reqVO) {
        if (reqVO.getBundleType() == null) {
            throw exception(BUNDLE_TYPE_REQUIRED);
        }
        
        // 自定义模式时，必须传入 costPrice
        if (reqVO.getBundleType() == 1 && reqVO.getCostPrice() == null) {
            throw exception(COST_PRICE_REQUIRED);
        }
        
        if (CollectionUtils.isEmpty(reqVO.getBundleItems())) {
            throw exception(BUNDLE_ITEMS_REQUIRED);
        }
        
        // 校验子产品是否存在
        for (ProductBundleItemReqVO item : reqVO.getBundleItems()) {
            ProductInfoDO subProduct = productInfoMapper.selectById(item.getSubProductId());
            if (subProduct == null) {
                throw exception(SUB_PRODUCT_NOT_EXISTS, item.getSubProductId());
            }
            
            // 防止组合产品嵌套（可选）
            if (subProduct.getProductType() != null && subProduct.getProductType() == 1) {
                throw exception(BUNDLE_PRODUCT_CANNOT_NEST);
            }
        }
    }

    /**
     * 创建组合关系（精简版：只存储关联关系）
     */
    private List<ProductBundleRelationDO> createBundleRelations(Long bundleProductId, 
                                                                List<ProductBundleItemReqVO> itemReqVOs) {
        List<ProductBundleRelationDO> relations = new ArrayList<>();
        
        for (ProductBundleItemReqVO itemReqVO : itemReqVOs) {
            // 创建关系（只存储关联信息，不存储冗余数据）
            ProductBundleRelationDO relation = ProductBundleRelationDO.builder()
                    .bundleProductId(bundleProductId)
                    .subProductId(itemReqVO.getSubProductId())
                    .quantity(itemReqVO.getQuantity())
                    .sortOrder(itemReqVO.getSortOrder() != null ? itemReqVO.getSortOrder() : 0)
                    .remark(itemReqVO.getRemark())
                    .build();
            
            relations.add(relation);
        }
        
        return relations;
    }

    /**
     * 计算组合产品成本价
     * 
     * @param bundleType 组合类型：1=自定义 2=自动累计
     * @param userInputCostPrice 用户输入的成本价（bundleType=1时使用）
     * @param relations 组合产品明细
     * @return 最终成本价
     */
    private BigDecimal calculateBundleCostPrice(Integer bundleType, 
                                               BigDecimal userInputCostPrice, 
                                               List<ProductBundleRelationDO> relations) {
        if (bundleType == 1) {
            // 自定义成本价模式：直接使用用户输入的值
            return userInputCostPrice;
        } else {
            // 自动累计模式：实时查询子产品成本价并累加
            BigDecimal totalCost = BigDecimal.ZERO;
            
            for (ProductBundleRelationDO relation : relations) {
                // 实时获取子产品信息
                ProductInfoDO subProduct = productInfoMapper.selectById(relation.getSubProductId());
                if (subProduct != null && subProduct.getCostPrice() != null) {
                    // 计算该项成本：单价 * 数量
                    BigDecimal itemCost = subProduct.getCostPrice()
                            .multiply(new BigDecimal(relation.getQuantity()));
                    totalCost = totalCost.add(itemCost);
                }
            }
            
            return totalCost;
        }
    }
}
```

---

### 五、Mapper层

#### 5.1 扩展现有 ProductInfoMapper

```java
@Mapper
public interface ProductInfoMapper extends BaseMapperX<ProductInfoDO> {
    
    // ========== 现有方法 ==========
    // ... 
    
    // ========== 新增方法 ==========
    
    /**
     * 查询指定类型和组合类型的产品列表
     */
    default List<ProductInfoDO> selectListByProductTypeAndBundleType(Integer productType, Integer bundleType) {
        return selectList(new LambdaQueryWrapperX<ProductInfoDO>()
                .eq(ProductInfoDO::getProductType, productType)
                .eq(ProductInfoDO::getBundleType, bundleType));
    }
}
```

#### 5.2 新增 ProductBundleRelationMapper

```java
package cn.iocoder.yudao.module.dm.dal.mysql.product;

import cn.iocoder.yudao.framework.mybatis.core.mapper.BaseMapperX;
import cn.iocoder.yudao.module.dm.dal.dataobject.product.ProductBundleRelationDO;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

/**
 * 产品组合关系 Mapper
 *
 * @author zeno
 */
@Mapper
public interface ProductBundleRelationMapper extends BaseMapperX<ProductBundleRelationDO> {

    /**
     * 根据组合产品ID查询明细列表
     */
    default List<ProductBundleRelationDO> selectListByBundleProductId(Long bundleProductId) {
        return selectList(ProductBundleRelationDO::getBundleProductId, bundleProductId);
    }

    /**
     * 根据组合产品ID删除明细
     */
    default void deleteByBundleProductId(Long bundleProductId) {
        delete(ProductBundleRelationDO::getBundleProductId, bundleProductId);
    }
    
    /**
     * 根据子产品ID查询关联关系（用于级联查询）
     */
    default List<ProductBundleRelationDO> selectListBySubProductId(Long subProductId) {
        return selectList(ProductBundleRelationDO::getSubProductId, subProductId);
    }
}
```

---

### 六、Controller层（扩展现有ProductInfoController）

```java
@Tag(name = "管理后台 - 产品信息")
@RestController
@RequestMapping("/dm/product-info")
@Validated
@Slf4j
public class ProductInfoController {

    @Resource
    private ProductInfoService productInfoService;

    // ========== 现有方法保持不变 ==========
    // createProductInfo, updateProductInfo, deleteProductInfo...
    // 这些方法内部逻辑已经支持组合产品

    // ========== 新增：组合产品专用方法 ==========

    @GetMapping("/bundle-relations")
    @Operation(summary = "获取组合产品明细列表")
    @Parameter(name = "bundleProductId", description = "组合产品ID", required = true)
    @PreAuthorize("@ss.hasPermission('dm:product-info:query')")
    public CommonResult<List<ProductBundleRelationDO>> getBundleRelations(
            @RequestParam("bundleProductId") Long bundleProductId) {
        return success(productInfoService.getBundleRelations(bundleProductId));
    }

    @PutMapping("/recalculate-bundle-cost")
    @Operation(summary = "重新计算组合产品成本价")
    @Parameter(name = "bundleProductId", description = "组合产品ID", required = true)
    @PreAuthorize("@ss.hasPermission('dm:product-info:update')")
    public CommonResult<Boolean> recalculateBundleCostPrice(
            @RequestParam("bundleProductId") Long bundleProductId) {
        productInfoService.recalculateBundleCostPrice(bundleProductId);
        return success(true);
    }

    @PutMapping("/batch-recalculate-bundle-cost")
    @Operation(summary = "批量重新计算组合产品成本价")
    @PreAuthorize("@ss.hasPermission('dm:product-info:update')")
    public CommonResult<Boolean> batchRecalculateBundleCostPrice() {
        productInfoService.batchRecalculateBundleCostPrice();
        return success(true);
    }
}
```

---

### 七、数据库变更总结

```sql
-- ========== 步骤1：修改现有表（只需2个字段！） ==========
ALTER TABLE `dm_product_info` 
ADD COLUMN `product_type` int DEFAULT 0 COMMENT '产品类型：0=普通产品 1=组合产品',
ADD COLUMN `bundle_type` int DEFAULT NULL COMMENT '组合类型：1=自定义成本价 2=自动累计成本价',
ADD INDEX `idx_product_type` (`product_type`, `deleted`);

-- 注意：cost_price 字段复用，无需新增额外成本价字段

-- ========== 步骤2：新增关联表（1张表，精简版）==========
CREATE TABLE `dm_product_bundle_relation` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  
  -- 关联关系（核心字段）
  `bundle_product_id` bigint NOT NULL COMMENT '组合产品ID',
  `sub_product_id` bigint NOT NULL COMMENT '子产品ID',
  
  -- 组合配置
  `quantity` int NOT NULL DEFAULT 1 COMMENT '数量',
  `sort_order` int DEFAULT 0 COMMENT '排序',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  
  -- 审计字段
  `creator` varchar(64) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updater` varchar(64) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否删除',
  `tenant_id` bigint DEFAULT 0 COMMENT '租户ID',
  
  PRIMARY KEY (`id`),
  KEY `idx_bundle_product` (`bundle_product_id`, `deleted`),
  KEY `idx_sub_product` (`sub_product_id`),
  KEY `idx_tenant` (`tenant_id`, `deleted`),
  UNIQUE KEY `uk_bundle_sub` (`bundle_product_id`, `sub_product_id`, `deleted`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='产品组合关系表';

-- 注意：不存储子产品的冗余数据（SKU、名称、单价等），查询时实时JOIN获取
```

**总结：**
- ✅ 只修改1张现有表，**仅增加2个字段**
- ✅ 只新增1张关联表
- ✅ **最小化数据库变更**

---

### 八、使用示例

#### 8.1 创建组合产品（自动累计模式）

```json
POST /dm/product-info/create

{
  "skuId": "COMBO-001",
  "skuName": "锅具5件套",
  "modelNumber": "COMBO-001",
  "unit": "套",
  "productType": 1,           // 组合产品
  "bundleType": 2,            // 自动累计（系统自动计算costPrice）
  "bundleItems": [
    {
      "subProductId": 5,      // 牛排机
      "quantity": 2
    },
    {
      "subProductId": 7,      // 叠叠锅
      "quantity": 1
    }
  ],
  "categoryId": 1,
  "brandId": 1,
  "description": "组合套餐"
}

// 结果：
// cost_price = 118*2 + 159*1 = 395（系统自动计算并保存）
```

#### 8.2 创建组合产品（自定义模式）

```json
POST /dm/product-info/create

{
  "skuId": "COMBO-002",
  "skuName": "特惠套装",
  "modelNumber": "COMBO-002",
  "productType": 1,           // 组合产品
  "bundleType": 1,            // 自定义
  "costPrice": 300.00,        // 用户手动指定固定成本价
  "bundleItems": [
    {
      "subProductId": 5,
      "quantity": 2
    },
    {
      "subProductId": 7,
      "quantity": 1
    }
  ]
}

// 结果：
// cost_price = 300（用户手动设置，不自动计算）
```

#### 8.3 查询组合产品

```json
GET /dm/product-info/get?id=100

// 响应：
{
  "id": 100,
  "skuId": "COMBO-001",
  "skuName": "锅具5件套",
  "productType": 1,
  "bundleType": 2,
  "costPrice": 395.00,  // 自动计算的成本价
  "bundleItems": [
    {
      "subProductId": 5,
      "subSkuId": "210-Gray",
      "subSkuName": "牛排机",
      "quantity": 2,
      "unitCostPrice": 118.00,
      "totalCostPrice": 236.00
    },
    {
      "subProductId": 7,
      "subSkuId": "261-White-5P",
      "subSkuName": "可拆卸手柄锅叠叠锅",
      "quantity": 1,
      "unitCostPrice": 159.00,
      "totalCostPrice": 159.00
    }
  ]
}
```

---

### 九、优势总结

✅ **最小化改动**
- 只修改1张现有表（增加4个字段）
- 只新增1张关联表
- 不影响现有业务逻辑

✅ **复用现有功能**
- 组合产品可以使用分类、品牌、供应商等所有功能
- 可以使用现有的成本结构管理（dm_product_costs）
- 可以使用现有的采购、销售流程

✅ **灵活性高**
- 支持自定义和自动累计两种模式
- 支持定时同步成本价
- 易于扩展

✅ **数据一致性**
- 事务保证
- 快照机制
- 级联删除

---

## 方案二：完全不增加表（JSON方案）- 不推荐

如果真的不能新增表，可以使用JSON字段方案：

```sql
-- 只修改 dm_product_info 表
ALTER TABLE `dm_product_info` 
ADD COLUMN `product_type` int DEFAULT 0 COMMENT '产品类型：0=普通 1=组合',
ADD COLUMN `bundle_type` int DEFAULT NULL COMMENT '组合类型：1=自定义 2=自动累计',
ADD COLUMN `bundle_items_json` json DEFAULT NULL COMMENT '组合明细JSON：[{subProductId, quantity, unitCost, totalCost}]';

-- 说明：cost_price 字段存储最终成本价
```

**缺点：**
- ❌ 无法建立外键约束
- ❌ 查询性能差
- ❌ 数据一致性难以保证
- ❌ 无法通过SQL直接查询子产品
- ❌ 维护困难

**仅在有极特殊限制时考虑此方案**

---

## 总结

**推荐使用方案一**：
- 📌 只修改1张表，只增加1张新表
- 📌 最小化改动，最大化复用
- 📌 数据结构清晰，易于维护
- 📌 性能优秀，扩展性强

这是在"不增加太多表"和"功能完善"之间的最佳平衡点！

